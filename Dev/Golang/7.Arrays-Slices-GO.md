# Go – Arrays et Slices

Ce chapitre poursuit le cours Go en s’appuyant sur la documentation **W3Schools (Go Arrays & Go Slices)**. Il introduit deux structures fondamentales pour manipuler des **collections de données** en Go : les **arrays** et les **slices**.

---

## 1. Arrays en Go

Un **array** est une collection de valeurs :
- de **même type**
- de **taille fixe** (définie à la déclaration)

---

## 1.1 Déclaration d’un array

### Syntaxe

```go
var nom [taille]type
```

### Exemple

```go
var nombres [3]int
```

Ici, `nombres` peut contenir exactement **3 entiers**.

---

## 1.2 Initialisation d’un array

```go
var nombres = [3]int{1, 2, 3}
```

Ou sans préciser la taille (le compilateur la déduit) :

```go
nombres := [...]int{1, 2, 3}
```

---

## 1.3 Accès aux éléments

Les indices commencent toujours à **0**.

```go
fmt.Println(nombres[0]) // premier élément
nombres[1] = 10         // modification
```

---

## 1.4 Parcourir un array

```go
for i := 0; i < len(nombres); i++ {
    fmt.Println(nombres[i])
}
```

Ou avec `range` :

```go
for index, valeur := range nombres {
    fmt.Println(index, valeur)
}
```

---

## 1.5 Limitations des arrays

- Taille **immuable**
- Peu flexibles
- Rarement utilisés seuls en pratique

Pour cette raison, Go privilégie les **slices**.

---

# 2. Slices en Go

Une **slice** est une vue dynamique sur un array.

Caractéristiques :
- Taille **variable**
- Plus flexible
- Très utilisée en Go

---

## 2.1 Déclaration d’une slice

### Syntaxe

```go
var nom []type
```

### Exemple

```go
var fruits []string
```

---

## 2.2 Initialisation d’une slice

```go
fruits := []string{"pomme", "banane", "orange"}
```

Contrairement aux arrays, aucune taille n’est imposée.

---

## 2.3 Créer une slice avec `make`

```go
nombres := make([]int, 5)
```

- longueur : 5
- valeurs par défaut : 0

Avec capacité définie :

```go
nombres := make([]int, 3, 10)
```

---

## 2.4 Longueur et capacité

- `len()` → nombre d’éléments
- `cap()` → capacité totale

```go
fmt.Println(len(nombres))
fmt.Println(cap(nombres))
```

---

## 2.5 Accès et modification

```go
fruits[0] = "kiwi"
fmt.Println(fruits[1])
```

---

## 2.6 Ajouter des éléments avec `append`

```go
fruits = append(fruits, "mangue")
```

Plusieurs valeurs :

```go
fruits = append(fruits, "ananas", "citron")
```

Si la capacité est dépassée, Go crée automatiquement un nouvel array sous-jacent.

---

## 2.7 Slicing (extraire une sous-slice)

```go
nombres := []int{1, 2, 3, 4, 5}

partie := nombres[1:4]
```

Résultat :

```go
[2 3 4]
```

Syntaxe générale :

```go
slice[debut:fin]
```

---

## 2.8 Parcourir une slice

```go
for _, valeur := range fruits {
    fmt.Println(valeur)
}
```

---

## 2.9 Différences entre array et slice

| Array            | Slice                  |
|------------------|------------------------|
| Taille fixe      | Taille dynamique       |
| Peu flexible     | Très flexible          |
| Rarement utilisé | Très utilisé           |
| Valeur copiée    | Référence sur un array |

---

## 3. Bonnes pratiques

- Utiliser les **slices** par défaut
- Utiliser `make()` lorsque la taille est connue à l’avance
- Éviter les arrays sauf cas spécifiques
- Toujours utiliser `range` pour la lisibilité

---

## 4. Résumé

Dans ce chapitre, tu as appris :

- Ce qu’est un array et comment l’utiliser
- Les limites des arrays
- Le fonctionnement des slices
- La différence entre longueur et capacité
- L’ajout et l’extraction d’éléments

